<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game with AI Backend</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .game-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .chess-board {
            width: 640px;
            height: 640px;
            border: 4px solid #8B4513;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            background: #f4f4f4;
        }

        .board-row {
            display: flex;
            height: 80px;
        }

        .square {
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .square.light {
            background-color: #f0d9b5;
        }

        .square.dark {
            background-color: #b58863;
        }

        .square.selected {
            box-shadow: inset 0 0 0 4px #ff6b35;
            background-color: #ffeb3b !important;
        }

        .square.possible-move {
            box-shadow: inset 0 0 0 4px #4caf50;
        }

        .square.last-move {
            box-shadow: inset 0 0 0 2px #2196f3;
        }

        .square:hover {
            opacity: 0.8;
        }

        .game-info {
            flex: 1;
            min-width: 300px;
        }

        .info-panel {
            background: rgba(255,255,255,0.95);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
        }

        .status {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }

        .turn-indicator {
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            text-align: center;
            font-weight: bold;
        }
        
        .white-turn {
            background: #f8f8f8;
            color: #333;
            border: 2px solid #ddd;
        }

        .black-turn {
            background: #333;
            color: #fff;
            border: 2px solid #666;
        }

        .captured-pieces {
            margin: 10px 0;
        }

        .captured-pieces h4 {
            margin: 10px 0 5px 0;
            color: #555;
        }

        .captured-list {
            font-size: 24px;
            line-height: 1.2;
        }

        .move-history {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            background: #fafafa;
        }

        .move-history h4 {
            margin-top: 0;
            color: #555;
        }

        .move {
            margin: 2px 0;
            font-family: monospace;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #4caf50;
            color: white;
        }

        .btn-secondary {
            background: #2196f3;
            color: white;
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .backend-status {
            background: rgba(255,255,255,0.9);
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }

        .connection-status {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .connected {
            background: #4caf50;
        }

        .disconnected {
            background: #f44336;
        }

        .loading {
            background: #ff9800;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .api-status {
            margin-top: 10px;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        .api-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .api-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="chess-board" id="chessBoard"></div>
        
        <div class="game-info">
            <div class="info-panel">
                <div class="status" id="gameStatus">Human vs AI Chess Game</div>
                <div class="turn-indicator" id="turnIndicator">
                    <span class="connection-status disconnected"></span>
                    White to move
                </div>
                
                <div class="captured-pieces">
                    <h4>Captured by White:</h4>
                    <div class="captured-list" id="capturedByWhite"></div>
                    <h4>Captured by Black:</h4>
                    <div class="captured-list" id="capturedByBlack"></div>
                </div>
            </div>

            <div class="info-panel">
                <div class="move-history">
                    <h4>Move History</h4>
                    <div id="moveList"></div>
                </div>
                
                <div class="controls">
                    <button class="btn-primary" onclick="newGame()">New Game</button>
                    <button class="btn-secondary" onclick="undoMove()" id="undoBtn">Undo</button>
                    <button class="btn-danger" onclick="resignGame()" id="resignBtn">Resign</button>
                </div>
            </div>

            <div class="backend-status">
                <h4>AI Opponent</h4>
                <p>You play as White, AI plays as Black. Make your move and the AI will respond automatically.</p>
                <p><strong>Your Move:</strong> <span id="currentMove">-</span></p>
                <p><strong>AI Status:</strong> <span id="aiResponse">Waiting for connection...</span></p>
                <div id="apiStatus"></div>
            </div>
        </div>
    </div>

    <script>
        // Chess game state
        let board = [];
        let currentPlayer = 'white';
        let selectedSquare = null;
        let gameHistory = [];
        let capturedPieces = { white: [], black: [] };
        let gameActive = true;
        let lastMove = null;
        let backendConnected = false;

        // API base URL
        const API_BASE = 'http://localhost:5000/api';

        // Chess pieces unicode symbols
        const pieces = {
            white: {
                king: '♔', queen: '♕', rook: '♖', 
                bishop: '♗', knight: '♘', pawn: '♙'
            },
            black: {
                king: '♚', queen: '♛', rook: '♜', 
                bishop: '♝', knight: '♞', pawn: '♟'
            }
        };

        // Initialize board with starting position
        function initializeBoard() {
            board = [
                ['♜','♞','♝','♛','♚','♝','♞','♜'],
                ['♟','♟','♟','♟','♟','♟','♟','♟'],
                [null,null,null,null,null,null,null,null],
                [null,null,null,null,null,null,null,null],
                [null,null,null,null,null,null,null,null],
                [null,null,null,null,null,null,null,null],
                ['♙','♙','♙','♙','♙','♙','♙','♙'],
                ['♖','♘','♗','♕','♔','♗','♘','♖']
            ];
            currentPlayer = 'white';
            selectedSquare = null;
            gameHistory = [];
            capturedPieces = { white: [], black: [] };
            gameActive = true;
            lastMove = null;
            renderBoard();
            updateGameInfo();
            
            // Initialize backend
            initializeBackend();
        }

        // Initialize backend connection
        async function initializeBackend() {
            try {
                const response = await fetch(`${API_BASE}/initialize`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({})
                });
                
                const data = await response.json();
                if (data.success) {
                    backendConnected = true;
                    updateConnectionStatus();
                    showApiStatus('Backend connected successfully!', 'success');
                    document.getElementById('aiResponse').textContent = 'Backend ready. Make your move!';
                } else {
                    throw new Error(data.error || 'Failed to initialize backend');
                }
            } catch (error) {
                console.error('Backend initialization failed:', error);
                backendConnected = false;
                updateConnectionStatus();
                showApiStatus('Backend connection failed: ' + error.message, 'error');
                document.getElementById('aiResponse').textContent = 'Backend unavailable. Running in offline mode.';
            }
        }

        // Update connection status indicator
        function updateConnectionStatus() {
            const statusElement = document.querySelector('.connection-status');
            statusElement.className = `connection-status ${backendConnected ? 'connected' : 'disconnected'}`;
        }

        // Show API status messages
        function showApiStatus(message, type) {
            const statusDiv = document.getElementById('apiStatus');
            statusDiv.textContent = message;
            statusDiv.className = `api-status api-${type}`;
            
            // Clear status after 5 seconds
            setTimeout(() => {
                statusDiv.textContent = '';
                statusDiv.className = '';
            }, 5000);
        }

        // Create the visual board
        function createBoard() {
            const boardElement = document.getElementById('chessBoard');
            boardElement.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                const rowElement = document.createElement('div');
                rowElement.className = 'board-row';
                
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.onclick = () => handleSquareClick(row, col);
                    
                    rowElement.appendChild(square);
                }
                
                boardElement.appendChild(rowElement);
            }
        }

        // Render current board state
        function renderBoard() {
            const squares = document.querySelectorAll('.square');
            squares.forEach(square => {
                const row = parseInt(square.dataset.row);
                const col = parseInt(square.dataset.col);
                square.textContent = board[row][col] || '';
                
                // Reset classes
                square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                
                // Highlight selected square
                if (selectedSquare && selectedSquare.row === row && selectedSquare.col === col) {
                    square.classList.add('selected');
                }
                
                // Highlight last move
                if (lastMove && 
                    ((lastMove.from.row === row && lastMove.from.col === col) ||
                     (lastMove.to.row === row && lastMove.to.col === col))) {
                    square.classList.add('last-move');
                }
                
                // Show possible moves
                if (selectedSquare && isValidMove(selectedSquare.row, selectedSquare.col, row, col)) {
                    square.classList.add('possible-move');
                }
            });
        }

        // Handle square clicks
        function handleSquareClick(row, col) {
            if (!gameActive) return;
            
            // ONLY allow White (human) to make moves
            if (currentPlayer !== 'white') {
                console.log('Not your turn! AI is thinking...');
                return;
            }

            const piece = board[row][col];
            
            if (selectedSquare) {
                if (selectedSquare.row === row && selectedSquare.col === col) {
                    // Deselect
                    selectedSquare = null;
                } else if (isValidMove(selectedSquare.row, selectedSquare.col, row, col)) {
                    // Make move
                    makeMove(selectedSquare.row, selectedSquare.col, row, col);
                    selectedSquare = null;
                } else if (piece && getPieceColor(piece) === 'white') {
                    // Select new white piece
                    selectedSquare = { row, col };
                } else {
                    selectedSquare = null;
                }
            } else if (piece && getPieceColor(piece) === 'white') {
                // Select white piece only
                selectedSquare = { row, col };
            }
            
            renderBoard();
        }

        // Get piece color
        function getPieceColor(piece) {
            if (!piece) return null;
            return '♔♕♖♗♘♙'.includes(piece) ? 'white' : 'black';
        }

        // Get piece type
        function getPieceType(piece) {
            if (!piece) return null;
            const typeMap = {
                '♔': 'king', '♚': 'king',
                '♕': 'queen', '♛': 'queen',
                '♖': 'rook', '♜': 'rook',
                '♗': 'bishop', '♝': 'bishop',
                '♘': 'knight', '♞': 'knight',
                '♙': 'pawn', '♟': 'pawn'
            };
            return typeMap[piece];
        }

        // Basic move validation (simplified)
        function isValidMove(fromRow, fromCol, toRow, toCol) {
            if (fromRow === toRow && fromCol === toCol) return false;
            if (toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) return false;
            
            const piece = board[fromRow][fromCol];
            const targetPiece = board[toRow][toCol];
            
            if (!piece) return false;
            if (targetPiece && getPieceColor(piece) === getPieceColor(targetPiece)) return false;
            
            const pieceType = getPieceType(piece);
            const color = getPieceColor(piece);
            
            // Basic movement patterns (simplified chess rules)
            switch (pieceType) {
                case 'pawn':
                    return isValidPawnMove(fromRow, fromCol, toRow, toCol, color);
                case 'rook':
                    return isValidRookMove(fromRow, fromCol, toRow, toCol);
                case 'bishop':
                    return isValidBishopMove(fromRow, fromCol, toRow, toCol);
                case 'queen':
                    return isValidQueenMove(fromRow, fromCol, toRow, toCol);
                case 'king':
                    return isValidKingMove(fromRow, fromCol, toRow, toCol);
                case 'knight':
                    return isValidKnightMove(fromRow, fromCol, toRow, toCol);
                default:
                    return false;
            }
        }

        function isValidPawnMove(fromRow, fromCol, toRow, toCol, color) {
            const direction = color === 'white' ? -1 : 1;
            const startRow = color === 'white' ? 6 : 1;
            const rowDiff = toRow - fromRow;
            const colDiff = Math.abs(toCol - fromCol);
            
            // Forward move
            if (colDiff === 0) {
                if (rowDiff === direction && !board[toRow][toCol]) return true;
                if (fromRow === startRow && rowDiff === 2 * direction && !board[toRow][toCol]) return true;
            }
            // Capture
            else if (colDiff === 1 && rowDiff === direction && board[toRow][toCol]) {
                return true;
            }
            
            return false;
        }

        function isValidRookMove(fromRow, fromCol, toRow, toCol) {
            if (fromRow !== toRow && fromCol !== toCol) return false;
            return isPathClear(fromRow, fromCol, toRow, toCol);
        }

        function isValidBishopMove(fromRow, fromCol, toRow, toCol) {
            if (Math.abs(fromRow - toRow) !== Math.abs(fromCol - toCol)) return false;
            return isPathClear(fromRow, fromCol, toRow, toCol);
        }

        function isValidQueenMove(fromRow, fromCol, toRow, toCol) {
            return isValidRookMove(fromRow, fromCol, toRow, toCol) || 
                   isValidBishopMove(fromRow, fromCol, toRow, toCol);
        }

        function isValidKingMove(fromRow, fromCol, toRow, toCol) {
            return Math.abs(fromRow - toRow) <= 1 && Math.abs(fromCol - toCol) <= 1;
        }

        function isValidKnightMove(fromRow, fromCol, toRow, toCol) {
            const rowDiff = Math.abs(fromRow - toRow);
            const colDiff = Math.abs(fromCol - toCol);
            return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
        }

        function isPathClear(fromRow, fromCol, toRow, toCol) {
            const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
            const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;
            
            let row = fromRow + rowStep;
            let col = fromCol + colStep;
            
            while (row !== toRow || col !== toCol) {
                if (board[row][col]) return false;
                row += rowStep;
                col += colStep;
            }
            
            return true;
        }

        // Make a move
        async function makeMove(fromRow, fromCol, toRow, toCol) {
            // Only allow White (human) to make moves
            if (currentPlayer !== 'white') {
                console.log('Not your turn!');
                return;
            }
            
            const piece = board[fromRow][fromCol];
            const capturedPiece = board[toRow][toCol];
            
            // Record move
            const move = {
                from: { row: fromRow, col: fromCol },
                to: { row: toRow, col: toCol },
                piece: piece,
                captured: capturedPiece,
                player: 'white'  // Always white for human moves
            };
            
            gameHistory.push(move);
            lastMove = move;
            
            // Handle capture
            if (capturedPiece) {
                const capturedColor = getPieceColor(capturedPiece);
                const capturingColor = capturedColor === 'white' ? 'black' : 'white';
                capturedPieces[capturingColor].push(capturedPiece);
            }
            
            // Move piece
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = null;
            
            // Switch to Black (AI turn)
            currentPlayer = 'black';
            
            updateGameInfo();
            
            // Send move to backend and get AI response
            if (backendConnected) {
                await sendMoveToBackend(move);
            } else {
                document.getElementById('aiResponse').textContent = 'Move made (offline mode)';
                // In offline mode, switch back to white after a delay
                setTimeout(() => {
                    currentPlayer = 'white';
                    updateGameInfo();
                }, 1000);
            }
            
            // Check for game end conditions (simplified)
            checkGameEnd();
        }

        // Send move to backend
        async function sendMoveToBackend(move) {
            const moveNotation = `${String.fromCharCode(97 + move.from.col)}${8 - move.from.row} to ${String.fromCharCode(97 + move.to.col)}${8 - move.to.row}`;
            document.getElementById('currentMove').textContent = moveNotation;
            
            // Show loading state
            document.getElementById('aiResponse').textContent = 'AI is thinking...';
            document.querySelector('.connection-status').className = 'connection-status loading';
            
            try {
                const response = await fetch(`${API_BASE}/move`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        from: move.from,
                        to: move.to,
                        piece: move.piece,
                        captured: move.captured
                    })
                });
                
                const data = await response.json();
                if (data.success) {
                    // Update board with AI move if provided
                    if (data.ai_coords) {
                        const aiMove = {
                            from: data.ai_coords.from,
                            to: data.ai_coords.to,
                            piece: board[data.ai_coords.from.row][data.ai_coords.from.col],
                            captured: board[data.ai_coords.to.row][data.ai_coords.to.col],
                            player: 'black'
                        };
                        
                        // Handle AI capture
                        if (aiMove.captured) {
                            const capturedColor = getPieceColor(aiMove.captured);
                            const capturingColor = capturedColor === 'white' ? 'black' : 'white';
                            capturedPieces[capturingColor].push(aiMove.captured);
                        }
                        
                        // Make AI move on board
                        board[aiMove.to.row][aiMove.to.col] = aiMove.piece;
                        board[aiMove.from.row][aiMove.from.col] = null;
                        
                        // Record AI move
                        gameHistory.push(aiMove);
                        lastMove = aiMove;
                        
                        // Switch back to White (human turn)
                        currentPlayer = 'white';
                        
                        // Update display
                        renderBoard();
                        updateGameInfo();
                    } else {
                        // If no AI move, switch back to white
                        currentPlayer = 'white';
                        updateGameInfo();
                    }
                    
                    document.getElementById('aiResponse').textContent = data.ai_response || 'AI move completed';
                    showApiStatus('AI responded successfully', 'success');
                    
                    // Check for game end after AI move
                    checkGameEnd();
                } else {
                    throw new Error(data.error || 'Failed to process move');
                }
            } catch (error) {
                console.error('Error sending move to backend:', error);
                document.getElementById('aiResponse').textContent = 'Backend communication failed';
                showApiStatus('Backend communication failed: ' + error.message, 'error');
                // On error, switch back to white
                currentPlayer = 'white';
                updateGameInfo();
            } finally {
                updateConnectionStatus();
            }
        }



        // Update game information display
        function updateGameInfo() {
            const turnIndicator = document.getElementById('turnIndicator');
            turnIndicator.innerHTML = `
                <span class="connection-status ${backendConnected ? 'connected' : 'disconnected'}"></span>
                ${gameActive ? (currentPlayer === 'white' ? 'White' : 'Black') + ' to move' : 'Game Over'}
            `;
            turnIndicator.className = `turn-indicator ${currentPlayer}-turn`;
            
            // Update captured pieces
            document.getElementById('capturedByWhite').textContent = capturedPieces.white.join(' ');
            document.getElementById('capturedByBlack').textContent = capturedPieces.black.join(' ');
            
            // Update move history
            const moveList = document.getElementById('moveList');
            moveList.innerHTML = '';
            gameHistory.forEach((move, index) => {
                const moveDiv = document.createElement('div');
                moveDiv.className = 'move';
                const fromPos = `${String.fromCharCode(97 + move.from.col)}${8 - move.from.row}`;
                const toPos = `${String.fromCharCode(97 + move.to.col)}${8 - move.to.row}`;
                moveDiv.textContent = `${index + 1}. ${move.piece} ${fromPos}-${toPos}${move.captured ? ' x' + move.captured : ''}`;
                moveList.appendChild(moveDiv);
            });
            
            // Scroll to bottom
            moveList.scrollTop = moveList.scrollHeight;
        }

        // Check for game end conditions (simplified)
        function checkGameEnd() {
            // This is a simplified check - in a full implementation, 
            // you'd check for checkmate, stalemate, etc.
            const kings = { white: false, black: false };
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece === '♔') kings.white = true;
                    if (piece === '♚') kings.black = true;
                }
            }
            
            if (!kings.white) {
                gameActive = false;
                document.getElementById('gameStatus').textContent = 'Black Wins!';
            } else if (!kings.black) {
                gameActive = false;
                document.getElementById('gameStatus').textContent = 'White Wins!';
            }
        }

        // Game control functions
        function newGame() {
            initializeBoard();
            document.getElementById('gameStatus').textContent = 'Human vs AI Chess Game';
            document.getElementById('currentMove').textContent = '-';
            document.getElementById('aiResponse').textContent = 'Ready to play!';
        }

        function undoMove() {
            if (gameHistory.length === 0) return;
            
            // Undo the last move (AI move)
            const lastMove = gameHistory.pop();
            
            // Restore piece positions
            board[lastMove.from.row][lastMove.from.col] = lastMove.piece;
            board[lastMove.to.row][lastMove.to.col] = lastMove.captured;
            
            // Restore captured pieces
            if (lastMove.captured) {
                const capturedColor = getPieceColor(lastMove.captured);
                const capturingColor = capturedColor === 'white' ? 'black' : 'white';
                const index = capturedPieces[capturingColor].indexOf(lastMove.captured);
                if (index > -1) {
                    capturedPieces[capturingColor].splice(index, 1);
                }
            }
            
            // If we just undid an AI move, also undo the human move
            if (lastMove.player === 'black' && gameHistory.length > 0) {
                const humanMove = gameHistory.pop();
                
                // Restore human move
                board[humanMove.from.row][humanMove.from.col] = humanMove.piece;
                board[humanMove.to.row][humanMove.to.col] = humanMove.captured;
                
                // Restore captured pieces from human move
                if (humanMove.captured) {
                    const capturedColor = getPieceColor(humanMove.captured);
                    const capturingColor = capturedColor === 'white' ? 'black' : 'white';
                    const index = capturedPieces[capturingColor].indexOf(humanMove.captured);
                    if (index > -1) {
                        capturedPieces[capturingColor].splice(index, 1);
                    }
                }
            }
            
            // Always set to white's turn after undo
            currentPlayer = 'white';
            gameActive = true;
            
            // Update last move
            lastMove = gameHistory.length > 0 ? gameHistory[gameHistory.length - 1] : null;
            
            renderBoard();
            updateGameInfo();
        }

        function resignGame() {
            gameActive = false;
            const winner = currentPlayer === 'white' ? 'Black' : 'White';
            document.getElementById('gameStatus').textContent = `${winner} Wins by Resignation!`;
            updateGameInfo();
        }

        // Initialize the game
        createBoard();
        initializeBoard();
    </script>
</body>
</html>
